[{"title":"多线程使用对象引发jvm崩溃","url":"/2019/11/28/多线程使用对象引发jvm崩溃/","content":"\n## 解决方法\n\n原因：多线程全局使用FindClass找到的对象时候，没有调用NewGlobalRef\n\n解决：FindClass之后调用NewGlobalRef转成全局jclass，记住结束的时候需要调用DeleteGlobalRef解除引用\n\n下面是分析过程，不感兴趣的可以不看了。\n\n## 崩溃现场\n\n### 线程\n\n```txt\n---------------  T H R E A D  ---------------\n\nCurrent thread (0x0000000002bbe000):  JavaThread \"main\" [_thread_in_vm, id=17356, stack(0x0000000002aa0000,0x0000000002ba0000)]\n\nsiginfo: ExceptionCode=0xc0000005, reading address 0xffffffffffffffff\n\nRegisters:\nRAX=0xdef27c76c186ca56, RBX=0x0000000002bbe000, RCX=0x000000066b134260, RDX=0x0000000000000000\nRSP=0x0000000002b9ec90, RBP=0x0000000002b9ed69, RSI=0x0000000038a789a8, RDI=0x0000000000000000\nR8 =0x0000000002bbe000, R9 =0x0000000000000000, R10=0x000000006e048eb0, R11=0x0000000002b9eca0\nR12=0x0000000000000001, R13=0x0000000000000000, R14=0x0000000002bbe1f8, R15=0x0000000000000001\nRIP=0x000000006d9ffb53, EFLAGS=0x0000000000010246\n```\n\n### 堆栈\n\n```txt\nStack: [0x0000000002aa0000,0x0000000002ba0000],  sp=0x0000000002b9ec90,  free space=1019k\nNative frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)\nV  [jvm.dll+0x15fb53]\nC  [xxxxjni.dll+0x3a48a]\nC  [xxxxjni.dll+0x3a7a4]\nC  [xxxxjni.dll+0x581fe]\nC  [xxxxjni.dll+0x550e7]\nC  [xxxxjni.dll+0x3de4c]\nC  [xxxxjni.dll+0x3b41e]\nC  0x0000000002cd8c67\n```\n\n## 调试过程\n\n通过windbg附加崩溃程序，转到jvm最后崩溃点：\n\n```txt\n0:025> u jvm.dll+0x15fb53\njvm!JNI_CreateJavaVM+0x1383:\n00000000`6d9ffb53 4c8b08          mov     r9,qword ptr [rax]\n00000000`6d9ffb56 488bc8          mov     rcx,rax\n00000000`6d9ffb59 41ff91b8000000  call    qword ptr [r9+0B8h]\n00000000`6d9ffb60 488bf0          mov     rsi,rax\n00000000`6d9ffb63 48397b08        cmp     qword ptr [rbx+8],rdi\n00000000`6d9ffb67 0f849d000000    je      jvm!JNI_CreateJavaVM+0x143a (00000000`6d9ffc0a)\n00000000`6d9ffb6d 48397c2428      cmp     qword ptr [rsp+28h],rdi\n00000000`6d9ffb72 740a            je      jvm!JNI_CreateJavaVM+0x13ae (00000000`6d9ffb7e)\n```\n\n结合崩溃现场的线程信息，可以得知崩溃的时候，[rax = 0xdef27c76c186ca56] rax被赋值了随机值，然后read时候，直接爆炸了...\n\n### 问题：为什么rax会赋值随机值\n\n结合源码分析，发现调用 jvm!JNI_CreateJavaVM 过程：\n\n业务代码 -> NewObject -> NewObjectV -> jvm!JNI_CreateJavaVM\n\n```c++\njobject resultObj = env->NewObject(gCls, gMethod, obj);\n\njobject NewObject(jclass clazz, jmethodID methodID, ...) {\n        va_list args;\n        jobject result;\n        va_start(args, methodID);\n        result = functions->NewObjectV(this,clazz,methodID,args);\n        va_end(args);\n        return result;\n    }\n\njobject NewObjectV(jclass clazz, jmethodID methodID,\n                    va_list args) {\n    return functions->NewObjectV(this,clazz,methodID,args);\n}\n```\n\n下面是正常情况下的执行流程：\n\n```asm\n00000000`6d9ea696 488b0b          mov     rcx,qword ptr [rbx]\n00000000`6d9ea699 e872eaf1ff      call    jvm!JVM_GetManagementExt+0x44f20 (00000000`6d909110)\n00000000`6d9ea69e 4c8bc7          mov     r8,rdi\n00000000`6d9ea6a1 33d2            xor     edx,edx\n00000000`6d9ea6a3 488bd8          mov     rbx,rax\n00000000`6d9ea6a6 488b00          mov     rax,qword ptr [rax] ds:00000007`c0060a18={jvm!InstanceKlass::`vftable' (00000000`6dea6728)}\n00000000`6d9ea6a9 488bcb          mov     rcx,rbx\n00000000`6d9ea6ac ff5078          call    qword ptr [rax+78h]\n00000000`6d9ea6af 48837f0800      cmp     qword ptr [rdi+8],0\n\n```\n\n可以看到00000000`6d9ea6a6这行，rax是vftable这种虚表。\n\nrax由00000000`6d9ea699此行的函数赋值，进去看看：\n\n```asm\n0:003> u 00000000`6d909110\njvm!JVM_GetManagementExt+0x44f20:\n00000000`6d909110 48630561277900  movsxd  rax,dword ptr [jvm!gHotSpotVMLongConstantEntryArrayStride+0x39b78 (00000000`6e09b878)]\n00000000`6d909117 488b0408        mov     rax,qword ptr [rax+rcx]\n```\n\n就两句代码。从gHotSpotVMLongConstantEntryArrayStride里面获取下表，然后加上rcx，取值返回。\n\n那就可以看00000000`6d9ea696这行的rbx哪里赋值了。\n\n经过调试发现，rbx其实就是 *gCls 的值。\n\n结合上述逻辑，转成 C 的伪代码那就是：\n\n```c\nrax = *((*gCls) + gHotSpotVMLongConstantEntryArrayStride)\n```\n\n正常情况下rax是不会变的，那么崩溃的时候rax确实是变化，那就证明：\ngcls指向的那一片内存中，发生了变动。要找到这种变动发生的地方，可以直接下内存写入断点，找到哪里修改了内存。\n\n```asm\n0:003> ba w1 00000006`6b134260\n0:003> g\nBreakpoint 0 hit\nmsvcr100!memset+0x8b:\n00000000`6e18c36b 4883c140        add     rcx,40h\n0:036> k\n # Child-SP          RetAddr           Call Site\n00 00000000`3dfdefd8 00000000`6d996a4e msvcr100!memset+0x8b\n01 00000000`3dfdefe0 00000000`6d996a95 jvm!JVM_GetManagementExt+0xd285e\n02 00000000`3dfdf010 00000000`6d9dcbe0 jvm!JVM_GetManagementExt+0xd28a5\n03 00000000`3dfdf040 00000000`6d957bff jvm!JVM_GetManagementExt+0x1189f0\n04 00000000`3dfdf080 00000000`031c685a jvm!JVM_GetManagementExt+0x93a0f\n```\n\n通过内存写入断点找到，发现了一根其他线程直接清理了gcls指向的那一块内存。\n\n### 答案\n\n两根线程竞态关系，线程1清理了gcls的内存，线程2却直接访问了被清理的内存，导致rax取值错误引发异常崩溃。","tags":["调试"]}]